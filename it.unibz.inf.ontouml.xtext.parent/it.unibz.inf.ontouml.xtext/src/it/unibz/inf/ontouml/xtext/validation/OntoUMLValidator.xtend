/*
 * generated by Xtext 2.13.0
 */
package it.unibz.inf.ontouml.xtext.validation

import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import it.unibz.inf.ontouml.xtext.xcore.OntoUMLClass
import com.google.inject.Inject
import it.unibz.inf.ontouml.xtext.utils.ModelUtils
import it.unibz.inf.ontouml.xtext.xcore.XcorePackage
import it.unibz.inf.ontouml.xtext.xcore.Model
import it.unibz.inf.ontouml.xtext.xcore.GeneralizationSet
import it.unibz.inf.ontouml.xtext.xcore.ModelElement
import it.unibz.inf.ontouml.xtext.xcore.Association
import it.unibz.inf.ontouml.xtext.xcore.EndurantType
import it.unibz.inf.ontouml.xtext.xcore.RegularAssociation
import it.unibz.inf.ontouml.xtext.xcore.RelationType
import org.eclipse.emf.common.util.BasicEList
import it.unibz.inf.ontouml.xtext.xcore.DerivationAssociation

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class OntoUMLValidator extends AbstractOntoUMLValidator {
	
	@Inject extension ModelUtils
	
	public static val DUPLICATED_NAME = "it.unibz.inf.ontouml.xtext.validation.DUPLICATED_NAME"
	public static val INVALID_GENERALIZATION_SET = "it.unibz.inf.ontouml.xtext.validation.INVALID_GENERALIZATION_SET"
	public static val UNKOWN_NATURE = "it.unibz.inf.ontouml.xtext.validation.UNKOWN_NATURE"
	public static val MISSING_IDENTITY_SUPPLIER = "it.unibz.inf.ontouml.xtext.validation.MISSING_IDENTITY_SUPPLIER"
	public static val ULTIMATE_SORTAL_SPECIALIZATION = "it.unibz.inf.ontouml.xtext.validation.ULTIMATE_SORTAL_SPECIALIZATION"
	public static val MULTIPLE_IDENTITY_SUPPLIERS = "it.unibz.inf.ontouml.xtext.validation.MULTIPLE_IDENTITY_SUPPLIERS"
	public static val NONSORTAL_SPECIALIZATION_TO_SORTAL = "it.unibz.inf.ontouml.xtext.validation.NONSORTAL_SPECIALIZATION_TO_SORTAL"
	public static val RIGID_SPECIALIZATION_TO_ANTI_RIGID = "it.unibz.inf.ontouml.xtext.validation.RIGID_SPECIALIZATION_TO_ANTI_RIGID"
	public static val SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID = "it.unibz.inf.ontouml.xtext.validation.SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID"
	public static val PHASE_MISSING_PARTITION = "it.unibz.inf.ontouml.xtext.validation.PHASE_MISSING_PARTITION"
	public static val MULTIPLE_DERIVATIONS = "it.unibz.inf.ontouml.xtext.validation.MULTIPLE_DERIVATIONS"
	public static val MISSING_DERIVATION = "it.unibz.inf.ontouml.xtext.validation.MISSING_DERIVATION"
	public static val PROHIBITED_DERIVATION = "it.unibz.inf.ontouml.xtext.validation.PROHIBITED_DERIVATION"
	public static val MISSING_INHERENCE = "it.unibz.inf.ontouml.xtext.validation.MISSING_INHERENCE"
	public static val INVALID_INHERENCE = "it.unibz.inf.ontouml.xtext.validation.INVALID_INHERENCE"
	public static val MISSING_DEPENDENCE = "it.unibz.inf.ontouml.xtext.validation.MISSING_DEPENDENCE"
	public static val MISSING_INVOLVEMENT = "it.unibz.inf.ontouml.xtext.validation.MISSING_INVOLVEMENT"
		
	
	@Check(CheckType.FAST)
	def checkDuplicatedName(ModelElement me) {
		val list = (me.eContainer as Model).elements
		if (list.exists[ it.name == me.name && it.eClass == me.eClass && it != me ])
			error('''There cannot be different model elements of the same type with a common name ("«me.nameOrAlias»").''',
				me, XcorePackage.eINSTANCE.modelElement_Name, DUPLICATED_NAME)
	}
	
	@Check(CheckType.FAST)
	def checkValidGeneralizationSet(GeneralizationSet gs) {
		val list = new BasicEList<ModelElement>
		gs.generalizations.forEach[ if(!list.contains(generic)) { list.add(generic) } ]
		if(list.size != 1)
			error('''All generalizations in a generalization set must have a common generic classifier''',
				gs, XcorePackage.eINSTANCE.modelElement_Name, INVALID_GENERALIZATION_SET)
	}
	
	@Check(CheckType.FAST)
	def checkUnkownOntologicalProperties(OntoUMLClass c) {
		if(c._type==EndurantType.NONE) {
			warning('''Unkown ontological nature. Classes without a valid OntoUML stereotype cannot '''
			 	+ '''be properly considered in model verification.''', c, 
			 	XcorePackage.eINSTANCE.modelElement_Name, UNKOWN_NATURE)
		}
	}
	
	@Check(CheckType.FAST)
	def checkUnkownOntologicalProperties(RegularAssociation a) {
		if(a._type==RelationType.NONE) {
			warning(''''Unkown ontological nature. Associations without a valid OntoUML stereotype cannot '''
				+ '''be properly considered in model verification.''', a, 
			 	XcorePackage.eINSTANCE.modelElement_Name, UNKOWN_NATURE)
		}
	}

	@Check(CheckType.NORMAL)
	def checkUltimateSortalSpecialization(OntoUMLClass c) {
		if (c.isSortal) {
			// This is the only heavy call for this rule. Thus I've decided to set CheckType as 
			// NORMAL but allow all if statements to be processed (no if-else declarations.
			val kinds = c.ancestors.filter[it.isUltimateSortal]
			
			if (kinds.isEmpty && !c.isUltimateSortal)
				error('''Missing specialization (direct or not) of an identity provider. Add '''
					+ '''generalization of some class decorated as «'«'»kind», «'«'»relatorKind»,'''
					+ '''«'«'»modeKind» or «'«'»qualityKind».''', c, 
					XcorePackage.eINSTANCE.modelElement_Name, MISSING_IDENTITY_SUPPLIER)

			if (!kinds.isEmpty && c.isUltimateSortal)
				error('''Identity providers cannot specialize other specialize others. Prohibited'''
					+ ''' specialization of the following classes ('''
					+ '''«FOR k : kinds»«IF kinds.head!=k», «ENDIF»"«k.nameOrAlias»"«ENDFOR»).''',
					c, XcorePackage.eINSTANCE.modelElement_Name, ULTIMATE_SORTAL_SPECIALIZATION)

			if (kinds.size > 1 && !c.isUltimateSortal)
				error('''Sortal classes cannot specialize multiple identity providers. Prohibited'''
					+ ''' specialization of the following classes ('''
					+ '''«FOR k : kinds»«IF kinds.head!=k», «ENDIF»"«k.nameOrAlias»"«ENDFOR»).''',
					c, XcorePackage.eINSTANCE.modelElement_Name,MULTIPLE_IDENTITY_SUPPLIERS)
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkNonSortalSpecializationToSortal(OntoUMLClass c) {
		if (c.isNonSortal) {
			val sortals = c.ancestors.filter[it.isSortal]
			
			if (!sortals.isEmpty)
				error('''Non-sortal classes cannot specialize sortal ones. Prohibited'''
					+ ''' specialization of the following classes ('''
					+ '''«FOR s : sortals»«IF sortals.head!=s», «ENDIF»'«s.nameOrAlias»'«ENDFOR»).''',
					XcorePackage.eINSTANCE.modelElement_Name, NONSORTAL_SPECIALIZATION_TO_SORTAL)
		}
	}
	
	// TODO Shifting validations to generalizations could be expressive enough and much more efficient
	@Check(CheckType.NORMAL)
	def checkNonAntiRigidSpecializationToAntiRigid(OntoUMLClass c) {
		if (c.isRigid || c.isSemiRigid) {
			val antiRigids = c.ancestors.filter[it.isAntiRigid]
			
			if (!antiRigids.isEmpty && c.isRigid)
				error('''Rigid classes cannot specialize anti-rigid ones. Prohibited'''
					+ ''' specialization of the following classes ('''
					+ '''«FOR at : antiRigids»«IF antiRigids.head!=at», «ENDIF»'«at.nameOrAlias»'«ENDFOR»).''',
					c, XcorePackage.eINSTANCE.modelElement_Name, RIGID_SPECIALIZATION_TO_ANTI_RIGID)
			
			else if (!antiRigids.isEmpty && c.isSemiRigid)
				error('''Mixin classes cannot specialize anti-rigid ones. Prohibited'''
					+ ''' specialization of the following classes ('''
					+ '''«FOR at : antiRigids»«IF antiRigids.head!=at», «ENDIF»'«at.nameOrAlias»'«ENDFOR»).''',
					c, XcorePackage.eINSTANCE.modelElement_Name, SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID)
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkPhaseInPartition(OntoUMLClass c) {
		if (c.isPhase) {
			val partitionFound = (c.eContainer as Model).elements
				.exists[ 
					if(it instanceof GeneralizationSet)
						isIsDisjoint
						&& isIsComplete 
						&& specifics.contains(c) 
						&& specifics.forall[ 
							it instanceof OntoUMLClass 
							&& (it as OntoUMLClass)._type == c._type
						]
					else 
						false
				]
			 // TODO change attribute's name
			 
			if(!partitionFound)
				warning('''Phase and phase-mixin classes should be grouped into phases-only generalization sets. ''',
					c, XcorePackage.eINSTANCE.modelElement_Name, PHASE_MISSING_PARTITION)
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkMultipleDerivationOfSingleAssociation(DerivationAssociation d) {
		val cond = d.containerModel.elements.exists[ 
			it instanceof DerivationAssociation
			&& it != d
			&& (it as DerivationAssociation).derivingAssociation == d.derivingAssociation
		]
		
		if(cond)
			error('''Multiple derivations of the same association are not allowed.''',
				d, XcorePackage.eINSTANCE.modelElement_Name, MULTIPLE_DERIVATIONS)
	}
	
	@Check(CheckType.NORMAL)
	def checkDescriptiveRelationDerivation(RegularAssociation a) {
		if(a._type==RelationType.DESCRIPTIVE) {
			val d = a.derivation
			if(d===null)
				warning('''Every descriptive relation should derive some class representing its truthmaker.''',
					a, XcorePackage.eINSTANCE.modelElement_Name, MISSING_DERIVATION)
			else if(!d.derivedClass.isMomentType)
				warning('''Descriptive relations cannot be deriving substantial types ('«d.derivedClass.name»').''',
					a, XcorePackage.eINSTANCE.modelElement_Name, PROHIBITED_DERIVATION)
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkDerivedMomentDependences(DerivationAssociation d) {
		val dc = d.derivedClass
		val dcKind = dc.kindType
		val relata = new BasicEList<OntoUMLClass>
		
		relata.add(d.derivingAssociation.endA)
		relata.add(d.derivingAssociation.endB)
		
		if(dcKind==EndurantType.MODE_KIND) {
			// This code might ignore specializations...
			// TODO reconsider implementation
			val inherence = dc.inherence
			
			if(inherence===null) {
				error('''Derived classes representing mode types must inhere in one of the relata''',
					 d, XcorePackage.eINSTANCE.derivationAssociation_DerivedClass, MISSING_INHERENCE)
				return ;
			}
			else if (!relata.contains(inherence.endB)) {
				error('''Derived classes representing mode types must inhere in one of the relata''', d,
					XcorePackage.eINSTANCE.derivationAssociation_DerivedClass, INVALID_INHERENCE)
				return;
			}
			
			val dependences = dc.dependences
			
			if(dependences.isEmpty || !dependences.exists[ relata.contains(endA) || relata.contains(endB) ]) {
				error('''Derived classes representing mode types must depende (externally) in one of the relata''',
					 d, XcorePackage.eINSTANCE.derivationAssociation_DerivedClass, MISSING_DEPENDENCE)
				return ;
			}
		}
		
		if(dcKind==EndurantType.RELATOR_KIND) {
			val involvements = dc.involvements
			
			if(involvements.isEmpty
				|| !involvements.exists[ relata.head==endA || relata.head==endB ]
				|| !!involvements.exists[ relata.tail==endA || relata.tail==endB ] 
			){
				error('''Derived classes representing relator types must involve all of the relata''',
					 d, XcorePackage.eINSTANCE.derivationAssociation_DerivedClass, MISSING_INVOLVEMENT)
			}
		}
	}
	
//	@Check(CheckType.NORMAL)
//	def checkRelatorParts() {
//		
//	}
	
	// TODO check parts of relators derived from relations
	
	// TODO Validate generalization relations
	// TODO Validate dependence relations
	// TODO Validate involvement relations
	// TODO Validate inherence relations (multiple occurrences, bounded entities...)
	// TODO check inherence of modes that are parts of relators
	// TODO Consider derivation relations involving qualities
	// TODO check external dependence of modes that are parts of relators
	// TODO Validate disjointness and generalization
	// TODO Validate duplicated generalizations
	// TODO Validate generalization cycles
	// TODO check cardinality constraints between relations and their derivations
	// TODO I need to define the rules and reification patterns for OntoUML class stereotypes
	
}
