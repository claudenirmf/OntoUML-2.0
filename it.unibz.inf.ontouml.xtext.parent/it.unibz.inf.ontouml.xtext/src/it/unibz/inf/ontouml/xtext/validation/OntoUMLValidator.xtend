/*
 * generated by Xtext 2.13.0
 */
package it.unibz.inf.ontouml.xtext.validation

import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import it.unibz.inf.ontouml.xtext.xcore.OntoUMLClass
import com.google.inject.Inject
import it.unibz.inf.ontouml.xtext.utils.ModelUtils
import it.unibz.inf.ontouml.xtext.xcore.XcorePackage
import it.unibz.inf.ontouml.xtext.xcore.Model
import it.unibz.inf.ontouml.xtext.xcore.GeneralizationSet
import it.unibz.inf.ontouml.xtext.xcore.ModelElement
import it.unibz.inf.ontouml.xtext.xcore.Association
import it.unibz.inf.ontouml.xtext.xcore.EndurantType
import it.unibz.inf.ontouml.xtext.xcore.RegularAssociation
import it.unibz.inf.ontouml.xtext.xcore.RelationType
import org.eclipse.emf.common.util.BasicEList
import it.unibz.inf.ontouml.xtext.xcore.DerivationAssociation

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class OntoUMLValidator extends AbstractOntoUMLValidator {
	
	@Inject extension ModelUtils
	
	public static val DUPLICATED_NAME = "it.unibz.inf.ontouml.xtext.validation.DUPLICATED_NAME"
	public static val INVALID_GENERALIZATION_SET = "it.unibz.inf.ontouml.xtext.validation.INVALID_GENERALIZATION_SET"
	public static val UNKOWN_NATURE = "it.unibz.inf.ontouml.xtext.validation.UNKOWN_NATURE"
	public static val MISSING_IDENTITY_SUPPLIER = "it.unibz.inf.ontouml.xtext.validation.MISSING_IDENTITY_SUPPLIER"
	public static val ULTIMATE_SORTAL_SPECIALIZATION = "it.unibz.inf.ontouml.xtext.validation.ULTIMATE_SORTAL_SPECIALIZATION"
	public static val MULTIPLE_IDENTITY_SUPPLIERS = "it.unibz.inf.ontouml.xtext.validation.MULTIPLE_IDENTITY_SUPPLIERS"
	public static val NONSORTAL_SPECIALIZATION_TO_SORTAL = "it.unibz.inf.ontouml.xtext.validation.NONSORTAL_SPECIALIZATION_TO_SORTAL"
	public static val RIGID_SPECIALIZATION_TO_ANTI_RIGID = "it.unibz.inf.ontouml.xtext.validation.RIGID_SPECIALIZATION_TO_ANTI_RIGID"
	public static val SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID = "it.unibz.inf.ontouml.xtext.validation.SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID"
	public static val PHASE_MISSING_PARTITION = "it.unibz.inf.ontouml.xtext.validation.PHASE_MISSING_PARTITION"
	public static val MULTIPLE_DERIVATIONS = "it.unibz.inf.ontouml.xtext.validation.MULTIPLE_DERIVATIONS"
	public static val MISSING_DERIVATION = "it.unibz.inf.ontouml.xtext.validation.MISSING_DERIVATION"
	public static val PROHIBITED_DERIVATION = "it.unibz.inf.ontouml.xtext.validation.PROHIBITED_DERIVATION"
	public static val MISSING_CHARACTERIZATION = "it.unibz.inf.ontouml.xtext.validation.MISSING_CHARACTERIZATION"
	public static val INVALID_CHARACTERIZATION = "it.unibz.inf.ontouml.xtext.validation.INVALID_CHARACTERIZATION"
	public static val MISSING_EXTERNAL_DEPENDENCE = "it.unibz.inf.ontouml.xtext.validation.MISSING_EXTERNAL_DEPENDENCE"
	public static val MISSING_MEDIATION = "it.unibz.inf.ontouml.xtext.validation.MISSING_MEDIATION"
	public static val MISSING_COMPARISSON_QUALITY_CHARACTERIZATION = "it.unibz.inf.ontouml.xtext.validation.MISSING_COMPARISSON_QUALITY_CHARACTERIZATION"
	public static val MISSING_PART_CHARACTERIZATION = "it.unibz.inf.ontouml.xtext.validation.MISSING_PART_CHARACTERIZATION"
	public static val MISSING_PART_EXTERNAL_DEPENDENCE = "it.unibz.inf.ontouml.xtext.validation.MISSING_PART_EXTERNAL_DEPENDENCE"
	public static val PROHIBITED_PART_EXTERNAL_DEPENDENCE = "it.unibz.inf.ontouml.xtext.validation.PROHIBITED_PART_EXTERNAL_DEPENDENCE"
		
	
	@Check(CheckType.FAST)
	def checkDuplicatedName(ModelElement me) {
		val list = (me.eContainer as Model).elements
		if (list.exists[ it.name == me.name && it.eClass == me.eClass && it != me ])
			error('''There cannot be different model elements of the same type with a common name ("«me.nameOrAlias»").''',
				me, XcorePackage.eINSTANCE.modelElement_Name, DUPLICATED_NAME)
	}
	
	@Check(CheckType.FAST)
	def checkValidGeneralizationSet(GeneralizationSet gs) {
		val list = new BasicEList<ModelElement>
		gs.generalizations.forEach[ if(!list.contains(generic)) { list.add(generic) } ]
		if(list.size != 1)
			error('''All generalizations in a generalization set must have a common generic classifier''',
				gs, XcorePackage.eINSTANCE.modelElement_Name, INVALID_GENERALIZATION_SET)
	}
	
	@Check(CheckType.FAST)
	def checkUnkownOntologicalProperties(OntoUMLClass c) {
		if(c._type==EndurantType.NONE) {
			warning('''Unkown ontological nature. Classes without a valid OntoUML stereotype cannot '''
			 	+ '''be properly considered in model verification.''', c, 
			 	XcorePackage.eINSTANCE.modelElement_Name, UNKOWN_NATURE)
		}
	}
	
	@Check(CheckType.FAST)
	def checkUnkownOntologicalProperties(RegularAssociation a) {
		if(a._type==RelationType.NONE) {
			if(a.isParthood)		return ; // TODO remove as soon as associated stereotypes are included
			
			warning(''''Unkown ontological nature. Associations without a valid OntoUML stereotype cannot '''
				+ '''be properly considered in model verification.''', a, 
			 	XcorePackage.eINSTANCE.modelElement_Name, UNKOWN_NATURE)
		}
	}

	@Check(CheckType.NORMAL)
	def checkUltimateSortalSpecialization(OntoUMLClass c) {
		if (c.isSortal) {
			// This is the only heavy call for this rule. Thus I've decided to set CheckType as 
			// NORMAL but allow all if statements to be processed (no if-else declarations.
			val kinds = c.ancestors.filter[it.isUltimateSortal]
			
			if (kinds.isEmpty && !c.isUltimateSortal)
				error('''Missing specialization (direct or not) of an identity provider. Add '''
					+ '''generalization of some class decorated as «'«'»kind», «'«'»relatorKind»,'''
					+ '''«'«'»modeKind» or «'«'»qualityKind».''', c, 
					XcorePackage.eINSTANCE.modelElement_Name, MISSING_IDENTITY_SUPPLIER)

			if (!kinds.isEmpty && c.isUltimateSortal)
				error('''Identity providers cannot specialize other specialize others. Prohibited'''
					+ ''' specialization of the following classes ('''
					+ '''«FOR k : kinds»«IF kinds.head!=k», «ENDIF»"«k.nameOrAlias»"«ENDFOR»).''',
					c, XcorePackage.eINSTANCE.modelElement_Name, ULTIMATE_SORTAL_SPECIALIZATION)

			if (kinds.size > 1 && !c.isUltimateSortal)
				error('''Sortal classes cannot specialize multiple identity providers. Prohibited'''
					+ ''' specialization of the following classes ('''
					+ '''«FOR k : kinds»«IF kinds.head!=k», «ENDIF»"«k.nameOrAlias»"«ENDFOR»).''',
					c, XcorePackage.eINSTANCE.modelElement_Name,MULTIPLE_IDENTITY_SUPPLIERS)
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkNonSortalSpecializationToSortal(OntoUMLClass c) {
		if (c.isNonSortal) {
			val sortals = c.ancestors.filter[it.isSortal]
			
			if (!sortals.isEmpty)
				error('''Non-sortal classes cannot specialize sortal ones. Prohibited'''
					+ ''' specialization of the following classes ('''
					+ '''«FOR s : sortals»«IF sortals.head!=s», «ENDIF»'«s.nameOrAlias»'«ENDFOR»).''',
					XcorePackage.eINSTANCE.modelElement_Name, NONSORTAL_SPECIALIZATION_TO_SORTAL)
		}
	}
	
	// TODO Shifting validations to generalizations could be expressive enough and much more efficient
	@Check(CheckType.NORMAL)
	def checkNonAntiRigidSpecializationToAntiRigid(OntoUMLClass c) {
		if (c.isRigid || c.isSemiRigid) {
			val antiRigids = c.ancestors.filter[it.isAntiRigid]
			
			if (!antiRigids.isEmpty && c.isRigid)
				error('''Rigid classes cannot specialize anti-rigid ones. Prohibited'''
					+ ''' specialization of the following classes ('''
					+ '''«FOR at : antiRigids»«IF antiRigids.head!=at», «ENDIF»'«at.nameOrAlias»'«ENDFOR»).''',
					c, XcorePackage.eINSTANCE.modelElement_Name, RIGID_SPECIALIZATION_TO_ANTI_RIGID)
			
			else if (!antiRigids.isEmpty && c.isSemiRigid)
				error('''Mixin classes cannot specialize anti-rigid ones. Prohibited'''
					+ ''' specialization of the following classes ('''
					+ '''«FOR at : antiRigids»«IF antiRigids.head!=at», «ENDIF»'«at.nameOrAlias»'«ENDFOR»).''',
					c, XcorePackage.eINSTANCE.modelElement_Name, SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID)
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkPhaseInPartition(OntoUMLClass c) {
		if (c.isPhase) {
			val partitionFound = (c.eContainer as Model).elements
				.exists[ 
					if(it instanceof GeneralizationSet)
						isIsDisjoint
						&& isIsComplete 
						&& specifics.contains(c) 
						&& specifics.forall[ 
							it instanceof OntoUMLClass 
							&& (it as OntoUMLClass)._type == c._type
						]
					else 
						false
				]
			 // TODO change attribute's name
			 
			if(!partitionFound)
				warning('''Phase and phase-mixin classes should be grouped into phases-only generalization sets. ''',
					c, XcorePackage.eINSTANCE.modelElement_Name, PHASE_MISSING_PARTITION)
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkMultipleDerivationOfSingleAssociation(DerivationAssociation d) {
		val cond = d.containerModel.elements.exists[ 
			it instanceof DerivationAssociation
			&& it != d
			&& (it as DerivationAssociation).derivingAssociation == d.derivingAssociation
		]
		
		if(cond)
			error('''Multiple derivations of the same association are not allowed.''',
				d, XcorePackage.eINSTANCE.modelElement_Name, MULTIPLE_DERIVATIONS)
	}
	
	@Check(CheckType.NORMAL)
	def checkDescriptiveRelationDerivation(RegularAssociation a) {
		if(a._type==RelationType.MATERIAL) {
			val d = a.derivation
			if(d===null)
				warning('''Every descriptive relation should derive some class representing its truthmaker.''',
					a, XcorePackage.eINSTANCE.modelElement_Name, MISSING_DERIVATION)
			else if(!d.derivedClass.isMomentType)
				warning('''Descriptive relations cannot be deriving substantial types ('«d.derivedClass.name»').''',
					a, XcorePackage.eINSTANCE.modelElement_Name, PROHIBITED_DERIVATION)
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkDerivedMomentDependences(DerivationAssociation d) {
		val dc = d.derivedClass
		
		val dcKind = dc.kindType
		val relata = new BasicEList<OntoUMLClass>
		
		relata.add(d.derivingAssociation.getSource)
		relata.add(d.derivingAssociation.getTarget)
		
		if(dcKind==EndurantType.MODE_KIND) {
			// This code might ignore specializations...
			// TODO reconsider implementation
			val inherence = dc.characterization
			
			if(inherence===null) {
				error('''Derived classes representing mode types must inhere in one of the relata''',
					 d, XcorePackage.eINSTANCE.derivationAssociation_DerivedClass, it.unibz.inf.ontouml.xtext.validation.OntoUMLValidator.MISSING_CHARACTERIZATION)
				return ;
			}
			else if (!relata.contains(inherence.getTarget)) {
				error('''Derived classes representing mode types must inhere in one of the relata''', d,
					XcorePackage.eINSTANCE.derivationAssociation_DerivedClass, it.unibz.inf.ontouml.xtext.validation.OntoUMLValidator.INVALID_CHARACTERIZATION)
				return;
			}
			
			val dependences = dc.externalDependences
			
			if(dependences.isEmpty || !dependences.exists[ relata.contains(getSource) || relata.contains(getTarget) ]) {
				error('''Derived classes representing mode types must depende (externally) in one of the relata''',
					 d, XcorePackage.eINSTANCE.derivationAssociation_DerivedClass, it.unibz.inf.ontouml.xtext.validation.OntoUMLValidator.MISSING_EXTERNAL_DEPENDENCE)
				return ;
			}
		}
		
		if(dcKind==EndurantType.RELATOR_KIND) {
			val involvements = dc.mediations
			
			if(involvements.isEmpty
				|| !involvements.exists[ relata.head==getSource || relata.head==getTarget ]
				|| !!involvements.exists[ relata.tail==getSource || relata.tail==getTarget ] 
			){
				error('''Derived classes representing relator types must involve all of the relata''',
					 d, XcorePackage.eINSTANCE.derivationAssociation_DerivedClass, it.unibz.inf.ontouml.xtext.validation.OntoUMLValidator.MISSING_MEDIATION)
			}
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkRelatorParts(OntoUMLClass part) {
		if(!part.isModeType)		return ;
		
		val x = part.parthoods
		
		x.forEach[ parthood |
			if(parthood.isTargetAWhole && parthood.source == part && parthood.target.isRelatorType) {
				val relator = parthood.target
				val mediated = relator.mediations.map[ it.target ].toSet
				val characterized = part.characterization?.target
				val externalDependences = part.externalDependences.map[ it.target ].toSet
				
				if(!mediated.contains(characterized)) {
					warning('''Modes that parts of relators must characterize one of the relata.''',
						part, XcorePackage.eINSTANCE.modelElement_Name, MISSING_PART_CHARACTERIZATION)
				}
				
				if(externalDependences.isEmpty) {
					warning('''Modes that parts of relators must externally depend on at least one of the relata.''',
						part, XcorePackage.eINSTANCE.modelElement_Name, MISSING_PART_EXTERNAL_DEPENDENCE)
				}
				else{ 
					externalDependences.forEach[ extDep |
						if(!mediated.contains(extDep)) {
							warning('''Modes that parts of relators must externally depedend exclusively on the relata of its whole.''',
								part, XcorePackage.eINSTANCE.modelElement_Name, PROHIBITED_PART_EXTERNAL_DEPENDENCE)
						}
//						else {
//							mediated.remove(extDep)
//						}
					]
				}
				
			}
		]
	}
	
	@Check(CheckType.NORMAL)
	def checkComparativeRelationDerivation(RegularAssociation comp) {
		if(comp._type==RelationType.COMPARATIVE) {
			val d = comp.derivation
			if(d===null)
				warning('''Every comparative relation should derive some class representing its truthmaker.''',
					comp, XcorePackage.eINSTANCE.modelElement_Name, MISSING_DERIVATION)
			else if(!d.derivedClass.isQualityType)
				warning('''Comparative relations have to derive some class representing a quality type ('«d.derivedClass.name»').''',
					comp, XcorePackage.eINSTANCE.modelElement_Name, PROHIBITED_DERIVATION)
		}
	}
	
	@Check(CheckType.NORMAL)
	def checkDerivedQualityDependency(DerivationAssociation d) {
		val quality = d.derivedClass
		if(!quality.isQualityType)	return ;
		
		val characterizedType = quality.characterization?.getTarget
		val relata = new BasicEList<OntoUMLClass>
		
		relata.add(d.derivingAssociation.getSource)
		relata.add(d.derivingAssociation.getTarget)
		
		val prob = relata.findFirst[ it != characterizedType && !it.ancestors.contains(characterizedType)]
		if(prob !== null) {
			warning('''The relata of a comparative relation must be characterized (or specialize a class that is) by the quality serving as truthmaker of the relation.''',
					prob, XcorePackage.eINSTANCE.modelElement_Name, MISSING_COMPARISSON_QUALITY_CHARACTERIZATION)
		}
	}
	
	// TODO Validate generalization relations
	// TODO Validate disjointness and generalization
	// TODO Validate duplicated generalizations
	// TODO Validate generalization cycles
	// TODO check cardinality constraints between relations and their derivations
	// TODO I need to define the rules and reification patterns for OntoUML class stereotypes
	
}
