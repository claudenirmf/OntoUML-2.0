/**
 * generated by Xtext 2.13.0
 */
package it.unibz.inf.ontouml.xtext.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import it.unibz.inf.ontouml.xtext.utils.ModelUtils;
import it.unibz.inf.ontouml.xtext.validation.AbstractOntoUMLValidator;
import it.unibz.inf.ontouml.xtext.xcore.Classifier;
import it.unibz.inf.ontouml.xtext.xcore.DerivationAssociation;
import it.unibz.inf.ontouml.xtext.xcore.EndurantType;
import it.unibz.inf.ontouml.xtext.xcore.Generalization;
import it.unibz.inf.ontouml.xtext.xcore.GeneralizationSet;
import it.unibz.inf.ontouml.xtext.xcore.Model;
import it.unibz.inf.ontouml.xtext.xcore.ModelElement;
import it.unibz.inf.ontouml.xtext.xcore.OntoUMLClass;
import it.unibz.inf.ontouml.xtext.xcore.RegularAssociation;
import it.unibz.inf.ontouml.xtext.xcore.RelationType;
import it.unibz.inf.ontouml.xtext.xcore.XcorePackage;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class OntoUMLValidator extends AbstractOntoUMLValidator {
  @Inject
  @Extension
  private ModelUtils _modelUtils;
  
  public final static String DUPLICATED_NAME = "it.unibz.inf.ontouml.xtext.validation.DUPLICATED_NAME";
  
  public final static String INVALID_GENERALIZATION_SET = "it.unibz.inf.ontouml.xtext.validation.INVALID_GENERALIZATION_SET";
  
  public final static String UNKOWN_NATURE = "it.unibz.inf.ontouml.xtext.validation.UNKOWN_NATURE";
  
  public final static String MISSING_IDENTITY_SUPPLIER = "it.unibz.inf.ontouml.xtext.validation.MISSING_IDENTITY_SUPPLIER";
  
  public final static String ULTIMATE_SORTAL_SPECIALIZATION = "it.unibz.inf.ontouml.xtext.validation.ULTIMATE_SORTAL_SPECIALIZATION";
  
  public final static String MULTIPLE_IDENTITY_SUPPLIERS = "it.unibz.inf.ontouml.xtext.validation.MULTIPLE_IDENTITY_SUPPLIERS";
  
  public final static String NONSORTAL_SPECIALIZATION_TO_SORTAL = "it.unibz.inf.ontouml.xtext.validation.NONSORTAL_SPECIALIZATION_TO_SORTAL";
  
  public final static String RIGID_SPECIALIZATION_TO_ANTI_RIGID = "it.unibz.inf.ontouml.xtext.validation.RIGID_SPECIALIZATION_TO_ANTI_RIGID";
  
  public final static String SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID = "it.unibz.inf.ontouml.xtext.validation.SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID";
  
  public final static String PHASE_MISSING_PARTITION = "it.unibz.inf.ontouml.xtext.validation.PHASE_MISSING_PARTITION";
  
  public final static String MULTIPLE_DERIVATIONS = "it.unibz.inf.ontouml.xtext.validation.MULTIPLE_DERIVATIONS";
  
  public final static String MISSING_DERIVATION = "it.unibz.inf.ontouml.xtext.validation.MISSING_DERIVATION";
  
  public final static String PROHIBITED_DERIVATION = "it.unibz.inf.ontouml.xtext.validation.PROHIBITED_DERIVATION";
  
  public final static String MISSING_INHERENCE = "it.unibz.inf.ontouml.xtext.validation.MISSING_INHERENCE";
  
  public final static String INVALID_INHERENCE = "it.unibz.inf.ontouml.xtext.validation.INVALID_INHERENCE";
  
  public final static String MISSING_DEPENDENCE = "it.unibz.inf.ontouml.xtext.validation.MISSING_DEPENDENCE";
  
  public final static String MISSING_INVOLVEMENT = "it.unibz.inf.ontouml.xtext.validation.MISSING_INVOLVEMENT";
  
  @Check(CheckType.FAST)
  public void checkDuplicatedName(final ModelElement me) {
    EObject _eContainer = me.eContainer();
    final EList<ModelElement> list = ((Model) _eContainer).getElements();
    final Function1<ModelElement, Boolean> _function = (ModelElement it) -> {
      return Boolean.valueOf(((Objects.equal(it.getName(), me.getName()) && Objects.equal(it.eClass(), me.eClass())) && (!Objects.equal(it, me))));
    };
    boolean _exists = IterableExtensions.<ModelElement>exists(list, _function);
    if (_exists) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("There cannot be different model elements of the same type with a common name (\"");
      String _nameOrAlias = this._modelUtils.nameOrAlias(me);
      _builder.append(_nameOrAlias);
      _builder.append("\").");
      this.error(_builder.toString(), me, XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.DUPLICATED_NAME);
    }
  }
  
  @Check(CheckType.FAST)
  public void checkValidGeneralizationSet(final GeneralizationSet gs) {
    final BasicEList<ModelElement> list = new BasicEList<ModelElement>();
    final Consumer<Generalization> _function = (Generalization it) -> {
      boolean _contains = list.contains(it.getGeneric());
      boolean _not = (!_contains);
      if (_not) {
        list.add(it.getGeneric());
      }
    };
    gs.getGeneralizations().forEach(_function);
    int _size = list.size();
    boolean _notEquals = (_size != 1);
    if (_notEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("All generalizations in a generalization set must have a common generic classifier");
      this.error(_builder.toString(), gs, XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.INVALID_GENERALIZATION_SET);
    }
  }
  
  @Check(CheckType.FAST)
  public void checkUnkownOntologicalProperties(final OntoUMLClass c) {
    EndurantType __type = c.get_type();
    boolean _equals = Objects.equal(__type, EndurantType.NONE);
    if (_equals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Unkown ontological nature. Classes without a valid OntoUML stereotype cannot ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("be properly considered in model verification.");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, c, 
        XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.UNKOWN_NATURE);
    }
  }
  
  @Check(CheckType.FAST)
  public void checkUnkownOntologicalProperties(final RegularAssociation a) {
    RelationType __type = a.get_type();
    boolean _equals = Objects.equal(__type, RelationType.NONE);
    if (_equals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\'Unkown ontological nature. Associations without a valid OntoUML stereotype cannot ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("be properly considered in model verification.");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, a, 
        XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.UNKOWN_NATURE);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkUltimateSortalSpecialization(final OntoUMLClass c) {
    boolean _isSortal = c.isSortal();
    if (_isSortal) {
      final Function1<OntoUMLClass, Boolean> _function = (OntoUMLClass it) -> {
        return Boolean.valueOf(it.isUltimateSortal());
      };
      final Iterable<OntoUMLClass> kinds = IterableExtensions.<OntoUMLClass>filter(this._modelUtils.getAncestors(c), _function);
      if ((IterableExtensions.isEmpty(kinds) && (!c.isUltimateSortal()))) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Missing specialization (direct or not) of an identity provider. Add ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("generalization of some class decorated as ");
        _builder_1.append("«");
        _builder_1.append("kind», ");
        _builder_1.append("«");
        _builder_1.append("relatorKind»,");
        String _plus = (_builder.toString() + _builder_1);
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("«");
        _builder_2.append("modeKind» or ");
        _builder_2.append("«");
        _builder_2.append("qualityKind».");
        String _plus_1 = (_plus + _builder_2);
        this.error(_plus_1, c, 
          XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.MISSING_IDENTITY_SUPPLIER);
      }
      if (((!IterableExtensions.isEmpty(kinds)) && c.isUltimateSortal())) {
        StringConcatenation _builder_3 = new StringConcatenation();
        _builder_3.append("Identity providers cannot specialize other specialize others. Prohibited");
        StringConcatenation _builder_4 = new StringConcatenation();
        _builder_4.append(" ");
        _builder_4.append("specialization of the following classes (");
        String _plus_2 = (_builder_3.toString() + _builder_4);
        StringConcatenation _builder_5 = new StringConcatenation();
        {
          for(final OntoUMLClass k : kinds) {
            {
              OntoUMLClass _head = IterableExtensions.<OntoUMLClass>head(kinds);
              boolean _notEquals = (!Objects.equal(_head, k));
              if (_notEquals) {
                _builder_5.append(", ");
              }
            }
            _builder_5.append("\"");
            String _nameOrAlias = this._modelUtils.nameOrAlias(k);
            _builder_5.append(_nameOrAlias);
            _builder_5.append("\"");
          }
        }
        _builder_5.append(").");
        String _plus_3 = (_plus_2 + _builder_5);
        this.error(_plus_3, c, XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.ULTIMATE_SORTAL_SPECIALIZATION);
      }
      if (((IterableExtensions.size(kinds) > 1) && (!c.isUltimateSortal()))) {
        StringConcatenation _builder_6 = new StringConcatenation();
        _builder_6.append("Sortal classes cannot specialize multiple identity providers. Prohibited");
        StringConcatenation _builder_7 = new StringConcatenation();
        _builder_7.append(" ");
        _builder_7.append("specialization of the following classes (");
        String _plus_4 = (_builder_6.toString() + _builder_7);
        StringConcatenation _builder_8 = new StringConcatenation();
        {
          for(final OntoUMLClass k_1 : kinds) {
            {
              OntoUMLClass _head_1 = IterableExtensions.<OntoUMLClass>head(kinds);
              boolean _notEquals_1 = (!Objects.equal(_head_1, k_1));
              if (_notEquals_1) {
                _builder_8.append(", ");
              }
            }
            _builder_8.append("\"");
            String _nameOrAlias_1 = this._modelUtils.nameOrAlias(k_1);
            _builder_8.append(_nameOrAlias_1);
            _builder_8.append("\"");
          }
        }
        _builder_8.append(").");
        String _plus_5 = (_plus_4 + _builder_8);
        this.error(_plus_5, c, XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.MULTIPLE_IDENTITY_SUPPLIERS);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkNonSortalSpecializationToSortal(final OntoUMLClass c) {
    boolean _isNonSortal = c.isNonSortal();
    if (_isNonSortal) {
      final Function1<OntoUMLClass, Boolean> _function = (OntoUMLClass it) -> {
        return Boolean.valueOf(it.isSortal());
      };
      final Iterable<OntoUMLClass> sortals = IterableExtensions.<OntoUMLClass>filter(this._modelUtils.getAncestors(c), _function);
      boolean _isEmpty = IterableExtensions.isEmpty(sortals);
      boolean _not = (!_isEmpty);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Non-sortal classes cannot specialize sortal ones. Prohibited");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append(" ");
        _builder_1.append("specialization of the following classes (");
        String _plus = (_builder.toString() + _builder_1);
        StringConcatenation _builder_2 = new StringConcatenation();
        {
          for(final OntoUMLClass s : sortals) {
            {
              OntoUMLClass _head = IterableExtensions.<OntoUMLClass>head(sortals);
              boolean _notEquals = (!Objects.equal(_head, s));
              if (_notEquals) {
                _builder_2.append(", ");
              }
            }
            _builder_2.append("\'");
            String _nameOrAlias = this._modelUtils.nameOrAlias(s);
            _builder_2.append(_nameOrAlias);
            _builder_2.append("\'");
          }
        }
        _builder_2.append(").");
        String _plus_1 = (_plus + _builder_2);
        this.error(_plus_1, 
          XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.NONSORTAL_SPECIALIZATION_TO_SORTAL);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkNonAntiRigidSpecializationToAntiRigid(final OntoUMLClass c) {
    if ((c.isRigid() || c.isSemiRigid())) {
      final Function1<OntoUMLClass, Boolean> _function = (OntoUMLClass it) -> {
        return Boolean.valueOf(it.isAntiRigid());
      };
      final Iterable<OntoUMLClass> antiRigids = IterableExtensions.<OntoUMLClass>filter(this._modelUtils.getAncestors(c), _function);
      if (((!IterableExtensions.isEmpty(antiRigids)) && c.isRigid())) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Rigid classes cannot specialize anti-rigid ones. Prohibited");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append(" ");
        _builder_1.append("specialization of the following classes (");
        String _plus = (_builder.toString() + _builder_1);
        StringConcatenation _builder_2 = new StringConcatenation();
        {
          for(final OntoUMLClass at : antiRigids) {
            {
              OntoUMLClass _head = IterableExtensions.<OntoUMLClass>head(antiRigids);
              boolean _notEquals = (!Objects.equal(_head, at));
              if (_notEquals) {
                _builder_2.append(", ");
              }
            }
            _builder_2.append("\'");
            String _nameOrAlias = this._modelUtils.nameOrAlias(at);
            _builder_2.append(_nameOrAlias);
            _builder_2.append("\'");
          }
        }
        _builder_2.append(").");
        String _plus_1 = (_plus + _builder_2);
        this.error(_plus_1, c, XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.RIGID_SPECIALIZATION_TO_ANTI_RIGID);
      } else {
        if (((!IterableExtensions.isEmpty(antiRigids)) && c.isSemiRigid())) {
          StringConcatenation _builder_3 = new StringConcatenation();
          _builder_3.append("Mixin classes cannot specialize anti-rigid ones. Prohibited");
          StringConcatenation _builder_4 = new StringConcatenation();
          _builder_4.append(" ");
          _builder_4.append("specialization of the following classes (");
          String _plus_2 = (_builder_3.toString() + _builder_4);
          StringConcatenation _builder_5 = new StringConcatenation();
          {
            for(final OntoUMLClass at_1 : antiRigids) {
              {
                OntoUMLClass _head_1 = IterableExtensions.<OntoUMLClass>head(antiRigids);
                boolean _notEquals_1 = (!Objects.equal(_head_1, at_1));
                if (_notEquals_1) {
                  _builder_5.append(", ");
                }
              }
              _builder_5.append("\'");
              String _nameOrAlias_1 = this._modelUtils.nameOrAlias(at_1);
              _builder_5.append(_nameOrAlias_1);
              _builder_5.append("\'");
            }
          }
          _builder_5.append(").");
          String _plus_3 = (_plus_2 + _builder_5);
          this.error(_plus_3, c, XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.SEMI_RIGID_SPECIALIZATION_TO_ANTI_RIGID);
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkPhaseInPartition(final OntoUMLClass c) {
    boolean _isPhase = c.isPhase();
    if (_isPhase) {
      EObject _eContainer = c.eContainer();
      final Function1<ModelElement, Boolean> _function = (ModelElement it) -> {
        boolean _xifexpression = false;
        if ((it instanceof GeneralizationSet)) {
          _xifexpression = (((((GeneralizationSet)it).isIsDisjoint() && ((GeneralizationSet)it).isIsComplete()) && ((GeneralizationSet)it).getSpecifics().contains(c)) && IterableExtensions.<Classifier>forall(((GeneralizationSet)it).getSpecifics(), 
            ((Function1<Classifier, Boolean>) (Classifier it_1) -> {
              return Boolean.valueOf(((it_1 instanceof OntoUMLClass) && Objects.equal(((OntoUMLClass) it_1).get_type(), c.get_type())));
            })));
        } else {
          _xifexpression = false;
        }
        return Boolean.valueOf(_xifexpression);
      };
      final boolean partitionFound = IterableExtensions.<ModelElement>exists(((Model) _eContainer).getElements(), _function);
      if ((!partitionFound)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Phase and phase-mixin classes should be grouped into phases-only generalization sets. ");
        this.warning(_builder.toString(), c, XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.PHASE_MISSING_PARTITION);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkMultipleDerivationOfSingleAssociation(final DerivationAssociation d) {
    final Function1<ModelElement, Boolean> _function = (ModelElement it) -> {
      return Boolean.valueOf((((it instanceof DerivationAssociation) && (!Objects.equal(it, d))) && Objects.equal(((DerivationAssociation) it).getDerivingAssociation(), d.getDerivingAssociation())));
    };
    final boolean cond = IterableExtensions.<ModelElement>exists(d.getContainerModel().getElements(), _function);
    if (cond) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Multiple derivations of the same association are not allowed.");
      this.error(_builder.toString(), d, XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.MULTIPLE_DERIVATIONS);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkDescriptiveRelationDerivation(final RegularAssociation a) {
    RelationType __type = a.get_type();
    boolean _equals = Objects.equal(__type, RelationType.DESCRIPTIVE);
    if (_equals) {
      final DerivationAssociation d = this._modelUtils.getDerivation(a);
      if ((d == null)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Every descriptive relation should derive some class representing its truthmaker.");
        this.warning(_builder.toString(), a, XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.MISSING_DERIVATION);
      } else {
        boolean _isMomentType = this._modelUtils.isMomentType(d.getDerivedClass());
        boolean _not = (!_isMomentType);
        if (_not) {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Descriptive relations cannot be deriving substantial types (\'");
          String _name = d.getDerivedClass().getName();
          _builder_1.append(_name);
          _builder_1.append("\').");
          this.warning(_builder_1.toString(), a, XcorePackage.eINSTANCE.getModelElement_Name(), OntoUMLValidator.PROHIBITED_DERIVATION);
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkDerivedMomentDependences(final DerivationAssociation d) {
    final OntoUMLClass dc = d.getDerivedClass();
    final EndurantType dcKind = this._modelUtils.getKindType(dc);
    final BasicEList<OntoUMLClass> relata = new BasicEList<OntoUMLClass>();
    relata.add(d.getDerivingAssociation().getEndA());
    relata.add(d.getDerivingAssociation().getEndB());
    boolean _equals = Objects.equal(dcKind, EndurantType.MODE_KIND);
    if (_equals) {
      final RegularAssociation inherence = this._modelUtils.getInherence(dc);
      if ((inherence == null)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Derived classes representing mode types must inhere in one of the relata");
        this.error(_builder.toString(), d, XcorePackage.eINSTANCE.getDerivationAssociation_DerivedClass(), OntoUMLValidator.MISSING_INHERENCE);
        return;
      } else {
        boolean _contains = relata.contains(inherence.getEndB());
        boolean _not = (!_contains);
        if (_not) {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Derived classes representing mode types must inhere in one of the relata");
          this.error(_builder_1.toString(), d, 
            XcorePackage.eINSTANCE.getDerivationAssociation_DerivedClass(), OntoUMLValidator.INVALID_INHERENCE);
          return;
        }
      }
      final Set<RegularAssociation> dependences = this._modelUtils.getDependences(dc);
      if ((dependences.isEmpty() || (!IterableExtensions.<RegularAssociation>exists(dependences, ((Function1<RegularAssociation, Boolean>) (RegularAssociation it) -> {
        return Boolean.valueOf((relata.contains(it.getEndA()) || relata.contains(it.getEndB())));
      }))))) {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Derived classes representing mode types must depende (externally) in one of the relata");
        this.error(_builder_2.toString(), d, XcorePackage.eINSTANCE.getDerivationAssociation_DerivedClass(), OntoUMLValidator.MISSING_DEPENDENCE);
        return;
      }
    }
    boolean _equals_1 = Objects.equal(dcKind, EndurantType.RELATOR_KIND);
    if (_equals_1) {
      final Set<RegularAssociation> involvements = this._modelUtils.getInvolvements(dc);
      if (((involvements.isEmpty() || (!IterableExtensions.<RegularAssociation>exists(involvements, ((Function1<RegularAssociation, Boolean>) (RegularAssociation it) -> {
        return Boolean.valueOf((Objects.equal(IterableExtensions.<OntoUMLClass>head(relata), it.getEndA()) || Objects.equal(IterableExtensions.<OntoUMLClass>head(relata), it.getEndB())));
      })))) || (!(!IterableExtensions.<RegularAssociation>exists(involvements, ((Function1<RegularAssociation, Boolean>) (RegularAssociation it) -> {
        return Boolean.valueOf((Objects.equal(IterableExtensions.<OntoUMLClass>tail(relata), it.getEndA()) || Objects.equal(IterableExtensions.<OntoUMLClass>tail(relata), it.getEndB())));
      })))))) {
        StringConcatenation _builder_3 = new StringConcatenation();
        _builder_3.append("Derived classes representing relator types must involve all of the relata");
        this.error(_builder_3.toString(), d, XcorePackage.eINSTANCE.getDerivationAssociation_DerivedClass(), OntoUMLValidator.MISSING_INVOLVEMENT);
      }
    }
  }
}
